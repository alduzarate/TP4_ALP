Queremos ver que State es una mónada. Por lo tanto, queremos verificar
las siguientes 3 propiedades:
1) return x >>= f   =   f x
2) t >>= return     =   t
3) (t >>= f) >>= g  =  t >>= (λx. f x >>= g)

Tenemos que:

newtype State a = State {runState :: Env → Pair a Env}

y que

return x = State (\s -> (x :!: s))

m >>= f = State (\s -> let (v :!: s') = runState m s 
                       in runState (f v) s')


Probemos 1)

return x >>= f

<==> def. >>=

State (λs → let (v :! : s') = runState (return x) s
            in runState (f v) s')

<==> def. return

State (λs → let (v :! : s') = runState (State (\s -> (x :!: s))) s
            in runState (f v) s')

<==> def. runState

State (λs → let (v :! : s') = (\s -> (x :!: s)) s
            in runState (f v) s')

<==> beta reduccion ??
State (λs → let (v :! : s') = (x :!: s)
            in runState (f v) s')

<==> def. let
State (\s -> runState (f x) s)

<==> etH?a red
State(runState (f x)) 

<==>  f x es de la forma State h => runState (State h) = h => tengo State(h) que asumi que era f x PFFFFFFFFFFF MIND BLOWN

f x

∎

Probemos 2):

t >> return

<==> def. >>=

State (\s ->  let (v :!: s') = runState t s 
              in runState (return v) s')

<==> def. return

State (\s ->  let (v :!: s') = runState t s 
              in runState State (\s -> (v :!: s)) s')

<==> def. runState

State (\s ->  let (v :!: s') = runState t s 
              in (v :!: s')

<==> def. let

State (\s -> runState t s)

<==> eta reduccion

State(runState t)

<==> t es de la forma State h => runState (State h) = h => tengo State (h) que asumi que era t

t

∎

Por último, probemos 3): (t >>= f) >>= g  ===  t >>= (λx. f x >>= g)

remember:
return x = State (\s -> (x :!: s))

m >>= f = State (\s -> let (v :!: s') = runState m s 
                       in runState (f v) s')

(t >>= f) >>= g

<==> def. 1er >>=

(State (\s -> let (v :!: s') = runState t s 
              in runState (f v) s')) >>= g



<==>  def. >>=

State (\w -> let (u :!: w') = runState (State (\s -> let (v :!: s') = runState t s 
                                                    in runState (f v) s')) w
              in runState (g u) w')

<==> def. runState

State (\w -> 
    let (u :!: w') = (\s -> let (v :!: s') = runState t s 
                                      in runState (f v) s') w
    in runState (g u) w')

<==> β-red

State (\w -> 
    let (u :!: w') = let (v :!: s') = runState t w 
                      in runState (f v) s'
    in runState (g u) w')

Si arrancamos del otro lado de la igualdad:

REMEMBER: m >>= f = State (\s -> let (v :!: s') = runState m s 
                       in runState (f v) s')
                       
t >>= (λx. f x >>= g)

<==> def. >>=
State (\s -> let (v :!: s') = runState t s 
                       in runState ((λx. f x >>= g) v) s')

<==> β-redux

State (\s -> let (v :!: s') = runState t s 
              in runState (f v >>= g)  s') 

<==> def. >>= 
State (\s -> let (v :!: s') = runState t s 
              in runState (State (\w -> let (u :!: w') = runState (f v) w 
                                        in runState (g u) w')
                          )  s')

<==> def. runState

State (\s -> let (v :!: s') = runState t s 
              in (\w -> let (u :!: w') = runState (f v) w 
                        in runState (g u) w') s')

<==> β-redux

State (\s -> let (v :!: s') = runState t s 
              in  let (u :!: w') = runState (f v) s' 
                  in runState (g u) w'

Propiedad let:
let x = let y = f
        in h y
in g x 

<==> mientras que y not in FV (g x)

let y = f 
in let x = h y
   in g x

Podemos ver (???) que (v :!: s') not in FV(runState (g u) w') entonces nos queda:

<==> Propiedad de Let enunciada

DAR VUELTA
State (\s -> let (v :!: s') = runState t s 
              in  let (u :!: w') = runState (f v) s' 
                  in runState (g u) w'

Uniendo ambos caminos, queda demostrado.           
∎ (t >>= f) >>= g  =  t >>= (λx. f x >>= g)



(f x) ==== (\y. f y) x --> contrario de beta

